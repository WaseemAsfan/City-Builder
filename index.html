<!--All of the objects in the scene have a texture and a bumpmap.
However the olny object in the scene where the bumpmap in not just a
white image is the wall and the donut. The smoke is an animated texture on a plane geometry.
I drew many of the texture myself including the donut texture (most are just 
noisy colors but the donut texture is nice in my opinion).-->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>City Builder</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Silkscreen:wght@700&display=swap');
    body {
      background: #6494bc;
      color: #ccc;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
    }

    .game-title {
     font-family: 'Silkscreen', monospace;
      font-size: 72px;
      font-weight: 700;
      color: #fda055;
      text-shadow: 
        8px 8px 0px  #ab5934,
        10px 10px 0px  #fda055;
      margin: 10px 0;
      text-align: center;
      letter-spacing: 4px;
      animation: bounce 1s ease-in-out infinite;
    }

    @keyframes bounce {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-10px);
      }
    }

    .subtitle {
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      color: #103545;
      margin-bottom: 20px;
      text-align: center;
      line-height: 1.8;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
      display: none;
    }

    canvas {
      border: 10px solid #237070;
    }

    .text-center{
      font-family: 'Silkscreen', monospace;
      font-size: 14px;
      background-color: #ab5934;
      border: 4px solid #ab5934;
      box-shadow: 4px 4px 0px #fda055;
      text-transform: uppercase;
      border-radius: 10px;
      color: #fff;
    }
    
    .btn {
      font-family: 'Silkscreen', monospace;
      font-size: 14px;
      border: 3px solid #000;
      box-shadow: 4px 4px 0px #000;
      text-transform: uppercase;
    }

    .btn.active {
      background-color: #fff;
      color: #000;
      border-color: #000;
      transform: translateY(2px);
      box-shadow: 2px 2px 0px #000;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 6px 6px 0px #000;
    }

    .button-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      justify-content: center;
    }
  </style>
</head>

<body>
  <h1 class="game-title">CITY BUILDER</h1>
  <p class="subtitle">
    MOUSE TO ROTATE | ARROW KEYS + W/S TO MOVE
  </p>

  <div style="display: flex; gap: 30px; align-items: center;">
    <!-- Left Buttons -->
    <div class="button-panel">
      <button id = "strtBtn" class="btn btn-success btn-lg">Start Game</button>
      <button id = "loadBtn" class="btn btn-primary btn-lg">Load City</button>
      <button id = "resetDrawBtn" class="btn btn-danger btn-lg">Reset</button>
      <button id = "resetCamBtn" class="btn btn-dark btn-lg">Reset Camera</button>
    </div>

    <!-- Canvas -->
    <div>
      <canvas id="glcanvas" width="1000" height="1000"></canvas>
    </div>

    <!-- Right Buttons -->
    <div class="button-panel">
      <button id = "unloadBtn" class="btn btn-info btn-lg">Unload City</button>
      <button id = "drawBtn" class="btn btn-warning btn-lg">Draw</button>
      <button id = "eraseBtn" class="btn btn-secondary btn-lg">Erase</button>
      <button id = "exitBtn" class="btn btn-danger btn-lg">Exit</button>
    </div>
  </div>

  <div id = 'score-div' class="text-center my-4">
  <h3>Score: <span class="badge bg-secondary" id="score-display">0</span></h3>
</div>

  <!-- Vertex shader -->
<textarea id="vertEditor"></textarea>
<textarea id="fragEditor"></textarea>
<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec3 aPosition;
in vec3 aColor;
in vec3 aNormal;
in vec2 aTexCoord;

uniform float uTime;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;

out vec3 vColor;
out vec2 vTexCoord;
out vec3 vNormal;
out vec3 vPosition;

void main() {
  vec4 viewPosition = uModelViewMatrix * uModelTransformationMatrix * vec4(aPosition, 1.0);
  vPosition = viewPosition.xyz;
  
  gl_Position = uProjectionMatrix * viewPosition;
  vColor = aColor;
  vTexCoord = aTexCoord;
  
  mat3 uNormalMatrix = transpose(inverse(mat3(uModelViewMatrix * uModelTransformationMatrix)));
  vNormal = normalize(uNormalMatrix * aNormal);
}
</script>
<!-- Fragment Shader -->
<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;

in vec3 vColor;
in vec2 vTexCoord;
in vec3 vNormal;
in vec3 vPosition;

out vec4 fragColor;

uniform sampler2D uTex;
uniform sampler2D uBumpTex;

// Material properties
uniform float uKa;
uniform float uKd;
uniform float uKs;
uniform float uAlpha;
uniform float uBumpStrength;

// Lighting properties
uniform vec3 uLightAPos;
uniform vec3 uLightBPos;
uniform vec3 uViewPos;

vec3 calculateLight(vec3 lightPos, vec3 normal, vec3 viewDir) {
  // Diffuse
  vec3 lightDir = normalize(lightPos - vPosition);
  float cosTheta = max(dot(normal, lightDir), 0.0);
  vec3 diffuse = uKd * cosTheta * vec3(1.0);
  
  // Specular
  vec3 reflectDir = -reflect(lightDir, normal);
  float spec = pow(max(dot(viewDir, reflectDir), 0.0), uAlpha);
  vec3 specular = uKs * spec * vec3(1.0);
  
  return diffuse + specular;
}

void main() {
  vec4 texColor = texture(uTex, vTexCoord);
  float h = texture(uBumpTex, vTexCoord).r;
  float hu = texture(uBumpTex, vTexCoord + vec2(0.01, 0.0)).r;
  float hv = texture(uBumpTex, vTexCoord + vec2(0.0, 0.01)).r;
  
  // Calculate gradient
  vec3 gradient = vec3(
    (hu - h) * uBumpStrength,
    (hv - h) * uBumpStrength,
    1.0
  );
  
  // Perturb the normal
  vec3 normal = normalize(vNormal + gradient);
  
  vec3 ambient = uKa * vec3(1.0);
  
  vec3 viewDir = normalize(uViewPos - vPosition);
  
  vec3 lightContribution = calculateLight(uLightAPos, normal, viewDir);
  lightContribution += calculateLight(uLightBPos, normal, viewDir);
  
  // Combine all color
  vec3 finalColor = (ambient + lightContribution) * texColor.rgb;
  fragColor = vec4(finalColor, texColor.a);
}
</script>
  <script src="primitives.js"></script>
  <script src="transformations.js"></script>
  <script src="person.js"></script>
  <script src="building.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    // WebGL setup
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");

    let vertEditor = document.getElementById("vertEditor");
    let fragEditor = document.getElementById("fragEditor");
    vertEditor.value = document.getElementById("vertex-shader").textContent;
    fragEditor.value = document.getElementById("fragment-shader").textContent;

    let program, posLoc, colorLoc, uMVM, uPM, uMTM, timeLoc;
    let vbo, nbo, ibo, tbo;
    let uTexLoc, texCoordLoc, normalLoc;
    // Buffers
    function initBuffers(shape) {
      let texbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.texCoords, gl.STATIC_DRAW);

      let posbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.positions, gl.STATIC_DRAW);

      let colbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.colors, gl.STATIC_DRAW);

      let indbuff = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indbuff); 
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);

      let normbuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normbuff);
      gl.bufferData(gl.ARRAY_BUFFER, shape.normals, gl.STATIC_DRAW);
      return {
        texbuff : texbuff,
        posbuff : posbuff,
        colbuff : colbuff,
        indbuff : indbuff,
        normbuff : normbuff
      };
    }

    const textureCache = {};

    function initTexture(url){
      // Return cached texture if it exists
      if (textureCache[url]) {
        return textureCache[url];
      }
      
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                    new Uint8Array([255, 255, 255, 255]));

      const image = new Image();
      image.src = url;
      image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
      }
      
      textureCache[url] = texture;
      return texture;
    }


    let uKaLoc, uKdLoc, uKsLoc, uAlphaLoc;
    let uLightAPosLoc, uViewPosLoc, uLightBPosLoc;
    let uBumpTexLoc, uBumpStrengthLoc;

    function initShaderProgram() {
      try {
        program = createProgram(gl, vertEditor.value, fragEditor.value);
        gl.useProgram(program);
        uTexLoc = gl.getUniformLocation(program, "uTex");
        texCoordLoc = gl.getAttribLocation(program, "aTexCoord");
        normalLoc = gl.getAttribLocation(program, "aNormal");

        uBumpTexLoc = gl.getUniformLocation(program, "uBumpTex");
        uBumpStrengthLoc = gl.getUniformLocation(program, "uBumpStrength");

        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        timeLoc = gl.getUniformLocation(program, "uTime");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");
        
        uKaLoc = gl.getUniformLocation(program, "uKa");
        uKdLoc = gl.getUniformLocation(program, "uKd");
        uKsLoc = gl.getUniformLocation(program, "uKs");
        uAlphaLoc = gl.getUniformLocation(program, "uAlpha");
        uLightAPosLoc = gl.getUniformLocation(program, "uLightAPos");
        uLightBPosLoc = gl.getUniformLocation(program, "uLightBPos");
        uViewPosLoc = gl.getUniformLocation(program, "uViewPos");
      } catch (e) { console.error(e); }
    }
    initShaderProgram();
    vertEditor.onkeyup = initShaderProgram;
    fragEditor.onkeyup = initShaderProgram;

    let count = -1;
    let checkForSelection = false;
    let selecting = "none";

    const unselectedTex = initTexture("textures/tile_blank.png");
    const selectedTex = initTexture("textures/tile_selected.png");
    const hoveredTex = initTexture("textures/tile_hover.png");
    const selectedHoveredTex = initTexture("textures/tile_selected_hover.png");
    const eraseTex = initTexture("textures/tile_erase.png");
    const selectedEraseTex = initTexture("textures/tile_selected_erase.png");
    const blankBumpTex = initTexture("textures/white.jpg")
    let gridSize = 10;
    let gridRow=gridSize-1; gridCol=gridSize-1;
    let personRow = Math.floor(gridSize/2), personCol = Math.floor(gridSize/2);
    let grid = [];
    let city = [];
    for(let j=0; j<gridSize; j++){
      grid[j] = [];
      for(let k=0; k<gridSize; k++){
        grid[j][k] = addTile(makePrism(1.0, 0.1, 1.0, 1.0, 1.0, 1.0), unselectedTex, blankBumpTex, makeMaterial(1.0, 0.0, 0.0, 5), 0);
        grid[j][k].isSelected = false;
        grid[j][k].hasBuilding = false;
      }
    }
    
    
    const drawBtn = document.getElementById('drawBtn');
    const eraseBtn = document.getElementById('eraseBtn');
    const resetBtn = document.getElementById('resetDrawBtn');
    const loadBtn = document.getElementById('loadBtn');
    const startBtn = document.getElementById("strtBtn");
    const unloadBtn = document.getElementById("unloadBtn");
    const camBtn = document.getElementById("resetCamBtn");
    const exitBtn = document.getElementById("exitBtn");

    startBtn.style.display = "none";
    camBtn.style.display = "none";
    unloadBtn.style.display = "none";
    exitBtn.style.display = "none";

    let currentMode = 'none'; // 'none', 'draw', or 'erase'
    let worldMode = "gridView"; // 'gridView', 'cityView', or 'personView'
    let buildingTiles =[];
    let packageStatus = "none"; // 'none', 'waiting', 'picked', or 'received'
    let packagePosition = 0;
    let packageGridCoords = [0,0];
    let deliveryPosition = 0;
    let deliveryGridCoords= 0;
    let score = 0;

    
    drawBtn.addEventListener('click', function() {
      if (currentMode === 'draw') {
        // If already in draw mode, turn it off
        currentMode = 'none';
        drawBtn.classList.remove('active');
        selecting = "none";
      } else {
        // Switch to draw mode
        currentMode = 'draw';
        drawBtn.classList.add('active');
        eraseBtn.classList.remove('active');
        grid[gridRow][gridCol].isSelected = true;
        selecting = "selecting";
      }
    });
   
    eraseBtn.addEventListener('click', function() {
      if (currentMode === 'erase') {
        // If already in erase mode, turn it off
        currentMode = 'none';
        eraseBtn.classList.remove('active');
        selecting = "none";
      } else {
        // Switch to erase mode
        currentMode = 'erase';
        eraseBtn.classList.add('active');
        drawBtn.classList.remove('active');
        grid[gridRow][gridCol].isSelected = false;
        selecting = "erasing";
      }
    });

    resetBtn.addEventListener('click', function() {
      currentMode = 'none';
      selecting = 'none';
      gridRow=gridSize-1; 
      gridCol=gridSize-1;
      eraseBtn.classList.remove('active');
      drawBtn.classList.remove('active');
      resetGrid();
    });
    
    loadBtn.addEventListener('click', function(){
      worldMode = "cityView"
      currentMode = 'none';
      eraseBtn.classList.remove('active');
      drawBtn.classList.remove('active');
      selecting = "none";
      loadCity();
      startBtn.style.display = "block";
      unloadBtn.style.display = "block";

      eraseBtn.style.display = "none";
      drawBtn.style.display = "none";
      loadBtn.style.display = "none";
      resetBtn.style.display = "none";
    
    });

    unloadBtn.addEventListener('click', function(){
      worldMode = "gridView"
      currentMode = 'none';
      eraseBtn.classList.remove('active');
      drawBtn.classList.remove('active');
      selecting = "none";
      resetCity();
      startBtn.style.display = "none";
      unloadBtn.style.display = "none";

      eraseBtn.style.display = "block";
      drawBtn.style.display = "block";
      loadBtn.style.display = "block";
      resetBtn.style.display = "block";
    });
    
    startBtn.addEventListener('click', function(){
      worldMode = "personView"
      startBtn.style.display = "none";
      unloadBtn.style.display = "none";

      camBtn.style.display = "block";
      exitBtn.style.display = "block";

      cubeRotX = 5 * Math.PI/180, cubeRotY = 0;
      camX = 0, camY = -0.35, camZ = -0.7;
      buildingTiles = [];
      for(let i=0; i<gridSize; i++){
        for(let j=0; j<gridSize; j++){
          if(grid[i][j].hasBuilding){
            let t = {row: i, col: j, hasPackage: false};
            buildingTiles.push(t);
          }
        }
      }
      score = 0;
      document.getElementById('score-display').textContent = score;
      packageStatus = "none";
    });

    camBtn.addEventListener('click',function(){
      cubeRotX = 5 * Math.PI/180, cubeRotY = 0;
      camX = 0, camY = -0.35, camZ = -0.7;
    });

    exitBtn.addEventListener('click', function(){
      worldMode = "cityView"
      camBtn.style.display = "none";
      exitBtn.style.display = "none";

      startBtn.style.display = "block";
      unloadBtn.style.display = "block";
      cubeRotX = 10 * Math.PI/180, cubeRotY = 0;
      camX = 0, camY = -0.72, camZ = -20;

      baseH.localTransform = mat4Translate(mat4Identity(), [0, 1.15, 0]);

      locationmatrix = mat4Identity(); 

      baseH.rotation = [0,0,0];
      characterRoot.rotation = [0,180*Math.PI/180, 0];
      movx = 0;
      movy = 0; 
      movz = 0;
      inverseRotation = mat4Identity();
      forward = false, backward= false, left= false, right= false;
    });

    // Mouse and keyboard interactions
    let mouseDown = false, lastX, lastY, cubeRotX = 10 * Math.PI/180, cubeRotY = 0; //
    let camX = 0, camY = -0.72, camZ = -20;
    let offsetx = 0, offsety = -0.5, offsetz = -2;

    canvas.addEventListener('mousedown', e => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
    canvas.addEventListener('mouseup', () => mouseDown = false);
    canvas.addEventListener('mousemove', e => {
      if (!mouseDown) return;
      let dx = e.clientX - lastX;
      let dy = e.clientY - lastY;
      cubeRotY += dx * 0.01;
      cubeRotX += dy * 0.01;
      lastX = e.clientX; lastY = e.clientY;
    });

    let startWalk = false;
    let finishWalk = false;
    let forward = false, backward= false, left= false, right= false;
    
    document.addEventListener('keydown', e => {
      const step = 0.2;
      switch (e.key) {
        case 'w': 
          if(worldMode == "personView"){
            startWalk = true;
            forward = true;
          }
          else{
            camZ += step; 
          } break;
        case 's': 
          if(worldMode == "personView"){
          }
          else{
            camZ -= step; 
          } break;
        case 'a':
          if(worldMode == "personView"){
            startWalk = true;
            left = true;
          } break;
        case 'd':
          if(worldMode == "personView"){
            startWalk = true;
            right = true;
          } break;
        case 'ArrowDown': if(worldMode == "gridView"){
          if(gridRow != personRow || gridCol-1 != personCol){
            if(gridCol-1 >= 0 && worldMode == "gridView"){
              gridCol--;
              if(selecting == "selecting"){
                grid[gridRow][gridCol].isSelected = true;
              }
              if(selecting == "erasing"){
                grid[gridRow][gridCol].isSelected = false;
              } 
            }
          } 
        }
        else{
          camY += step;
        } break;
        case 'ArrowUp': if(worldMode == "gridView"){
          if(gridRow != personRow || gridCol+1 != personCol){
            if(gridCol+1 < gridSize){
              gridCol++;
              if(selecting == "selecting"){
                grid[gridRow][gridCol].isSelected = true;
              }
              if(selecting == "erasing"){
                grid[gridRow][gridCol].isSelected = false;
              }
            }
          }
        }
        else{
          camY -= step;
        } break;
        case 'ArrowRight': if(worldMode == "gridView"){
          if(gridRow-1 != personRow || gridCol != personCol){
            if(gridRow-1 >= 0 && worldMode == "gridView"){
              gridRow--; 
              if(selecting == "selecting"){
                grid[gridRow][gridCol].isSelected = true;
              }
              if(selecting == "erasing"){
                grid[gridRow][gridCol].isSelected = false;
              }
            }
          }
        } 
        else if(worldMode == "cityView"){
          camX -= step;
        }
        else{
          camZ += step;
        }break;
        case 'ArrowLeft': if(worldMode == "gridView"){
          if(gridRow+1 != personRow || gridCol != personCol){
            if(gridRow+1 < gridSize && worldMode == "gridView"){
              gridRow++;
              if(selecting == "selecting"){
                grid[gridRow][gridCol].isSelected = true;
              }
              if(selecting == "erasing"){
                grid[gridRow][gridCol].isSelected = false;
              }
            }
          }
        } 
        else if(worldMode == "cityView"){
          camX += step;
        }
        else{
          camZ -= step;
        } break;
      }
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'w' && worldMode == "personView") {
        forward = false;
      }
      if (e.key === 'd' && worldMode == "personView") {
        right = false;
      }
      if (e.key === 'a' && worldMode == "personView") {
        left = false;
      }

      // // Optional: stop walking animation on any arrow release
      if (['w','a','s','d'].includes(e.key)) {
        startWalk = false;
      }
    });

    function resetGrid(){
      for(let i =0; i < gridSize; i ++){
        for(let j = 0; j < gridSize; j++){
          grid[i][j].isSelected = false;
          grid[i][j].hasBuilding = false;
          grid[i][j].texture = unselectedTex;
        }
      }
    }
    

    let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 100;
    let f = 1 / Math.tan(fov / 2);
    let proj = new Float32Array([
      f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zFar + zNear) / (zNear - zFar), -1, 0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
    ]);

    let startTime = Date.now();

    
    function addGeometry(shape, texUrl, bumpUrl, material, bumpStrength){
      let buffs = initBuffers(shape);
      let texture = initTexture(texUrl);
      let bumpTexture = initTexture(bumpUrl);
      count ++;
      return{
        posbuff : buffs.posbuff,
        colbuff : buffs.colbuff,
        indbuff : buffs.indbuff,
        texbuff : buffs.texbuff,
        normbuff : buffs.normbuff,
        transformations : mat4Identity(),
        indicelen : shape.indices.length,
        texture : texture,
        bumpTexture : bumpTexture,
        material : material,
        bumpStrength : bumpStrength,
        textcount : count
      };
    }
    function makeMaterial(a,d,s,alph){
      return{
      ka: a,    // Ambient
      kd: d,    // Diffuse
      ks: s,    // Specular
      alpha: alph // Shininess
      };
    };

    function createNode(drawFunc, shapeGeometry) {
      let node = {
        translation: [0, 0, 0],
        rotation: [0, 0, 0],
        scale: [1, 1, 1],
        localTransform: mat4Identity(),
        drawFunc: drawFunc,
        children: [],
        shapeGeometry : shapeGeometry
      };

      return node;
    }
    //function to add a child node to a parent node
    function addChild(parent, child) {
      parent.children.push(child);
    }

    function addTile(shape, texture, bumpTexture, material, bumpStrength){
      let buffs = initBuffers(shape);
      count ++;
      return{
        posbuff : buffs.posbuff,
        colbuff : buffs.colbuff,
        indbuff : buffs.indbuff,
        texbuff : buffs.texbuff,
        normbuff : buffs.normbuff,
        transformations : mat4Identity(),
        indicelen : shape.indices.length,
        texture : texture,
        bumpTexture : bumpTexture,
        material : material,
        bumpStrength : bumpStrength,
        textcount : count
      };
    }

    //DFS structure to go through apply transformations and draw each node
    function drawNode(gl, node, parentMatrix) {
      const transform = multiplyMat4(
        translationMatrix(node.translation),
        multiplyMat4(rotationMatrix(node.rotation), scaleMatrix(node.scale))
      );
      const worldMatrix = multiplyMat4(parentMatrix, transform);
      gl.uniformMatrix4fv(uMTM, false, multiplyMat4(worldMatrix, node.localTransform));
      node.drawFunc(gl, node.shapeGeometry);
      for (let child of node.children)
        drawNode(gl, child, worldMatrix);
    }
    
    function drawfunc(gl, shapeGeometry){
      // let i = shapeGeometry.textcount;
      i = 0
      gl.uniform1f(uKaLoc, shapeGeometry.material.ka);
      gl.uniform1f(uKdLoc, shapeGeometry.material.kd);
      gl.uniform1f(uKsLoc, shapeGeometry.material.ks);
      gl.uniform1f(uAlphaLoc, shapeGeometry.material.alpha);
      gl.uniform1f(uBumpStrengthLoc, shapeGeometry.bumpStrength);

      gl.activeTexture(gl.TEXTURE0 + i); //unit is 0, 1, 2 ...
      gl.bindTexture(gl.TEXTURE_2D, shapeGeometry.texture);
      gl.uniform1i(uTexLoc,0 + i);

      gl.activeTexture(gl.TEXTURE1 + i);
      gl.bindTexture(gl.TEXTURE_2D, shapeGeometry.bumpTexture);
      gl.uniform1i(uBumpTexLoc, 1+i);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.texbuff);
      gl.enableVertexAttribArray(texCoordLoc);
      gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.posbuff);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.colbuff);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shapeGeometry.indbuff);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.normbuff);
      gl.enableVertexAttribArray(normalLoc);
      gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

      // gl.uniformMatrix4fv(uMTM, false, shapeGeometry.transformations);
      gl.drawElements(gl.TRIANGLES, shapeGeometry.indicelen, gl.UNSIGNED_SHORT, 0);
    }

    function drawStrayFunc(gl, shapeGeometry){
      let i = 0 ;
      gl.uniform1f(uKaLoc, shapeGeometry.material.ka);
      gl.uniform1f(uKdLoc, shapeGeometry.material.kd);
      gl.uniform1f(uKsLoc, shapeGeometry.material.ks);
      gl.uniform1f(uAlphaLoc, shapeGeometry.material.alpha);
      gl.uniform1f(uBumpStrengthLoc, shapeGeometry.bumpStrength);

      gl.activeTexture(gl.TEXTURE0 + i); //unit is 0, 1, 2 ...
      gl.bindTexture(gl.TEXTURE_2D, shapeGeometry.texture);
      gl.uniform1i(uTexLoc,0 + i);

      gl.activeTexture(gl.TEXTURE1 + i);
      gl.bindTexture(gl.TEXTURE_2D, shapeGeometry.bumpTexture);
      gl.uniform1i(uBumpTexLoc, 1+i);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.texbuff);
      gl.enableVertexAttribArray(texCoordLoc);
      gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.posbuff);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.colbuff);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shapeGeometry.indbuff);

      gl.bindBuffer(gl.ARRAY_BUFFER, shapeGeometry.normbuff);
      gl.enableVertexAttribArray(normalLoc);
      gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

      gl.uniformMatrix4fv(uMTM, false, shapeGeometry.transformations);
      gl.drawElements(gl.TRIANGLES, shapeGeometry.indicelen, gl.UNSIGNED_SHORT, 0);
    }

    function loadCity(){
      // console.log("loading city");
      let tmp = Math.floor(gridSize/2);
      for(let i = 0; i < gridSize; i++){
        for(let j = 0; j < gridSize; j++){
          if(grid[i][j].isSelected && !grid[i][j].hasBuilding){
            let seed = Math.floor(Math.random() * 4) + 1;
            let rot = Math.floor(Math.random() * 4);
            if(seed == 1){
              let building = createbuilding1Model();
              moveBuilding(building,1, tmp-i, tmp-j, rot);
              city.push(building);
              grid[i][j].hasBuilding = true;
            }
            else if(seed==2){
              let building = createbuilding2Model();
              moveBuilding(building,2, tmp-i, tmp-j, rot);
              city.push(building);
              grid[i][j].hasBuilding = true;
            }
            else if (seed==3){
              let building = createbuilding3Model();
              moveBuilding(building,3, tmp-i, tmp-j, rot);
              city.push(building);
              grid[i][j].hasBuilding = true;
            }
            else{
              let placed = false;
              if(i-1 > -1 && !placed){
                if(grid[i-1][j].isSelected && !grid[i-1][j].hasBuilding){
                  let building = createbuilding4Model();
                  let n = Math.floor(Math.random() * 2) + 1;
                  if(n == 1){
                    moveBuilding(building,4, tmp-i+1, tmp-j, 2);
                  }
                  else{
                    moveBuilding(building,4, tmp-i, tmp-j, 0);
                  }
                  city.push(building);
                  grid[i][j].hasBuilding = true;
                  grid[i-1][j].hasBuilding = true;
                  placed = true;
                }
              }
              if(j-1 > -1 && !placed){
                if(grid[i][j-1].isSelected && !grid[i][j-1].hasBuilding){
                  let building = createbuilding4Model();
                  let n = Math.floor(Math.random() * 2) + 1;
                  if(n == 1){
                    moveBuilding(building,4, tmp-i, tmp-j+1, 3);
                  }
                  else{
                    moveBuilding(building,4, tmp-i, tmp-j, 1);
                  }
                  city.push(building);
                  grid[i][j].hasBuilding = true;
                  grid[i][j-1].hasBuilding = true;
                  placed = true;
                }
              }
              if(i+1 <gridSize && !placed){
                if(grid[i+1][j].isSelected && !grid[i+1][j].hasBuilding){
                  let building = createbuilding4Model();
                  let n = Math.floor(Math.random() * 2) + 1;
                  if(n == 1){
                    moveBuilding(building,4, tmp-i-1, tmp-j, 0);
                  }
                  else{
                    moveBuilding(building,4, tmp-i, tmp-j, 2);
                  }
                  city.push(building);
                  grid[i][j].hasBuilding = true;
                  grid[i+1][j].hasBuilding = true;
                  placed = true;
                }
              }
              if(j+1 < gridSize && !placed){
                if(grid[i][j+1].isSelected && !grid[i][j+1].hasBuilding){
                  let building = createbuilding4Model();
                  let n = Math.floor(Math.random() * 2) + 1;
                  if(n == 1){
                    moveBuilding(building,4, tmp-i, tmp-j-1, 1);
                  }
                  else{
                    moveBuilding(building,4, tmp-i, tmp-j, 3);
                  }
                  city.push(building);
                  grid[i][j].hasBuilding = true;
                  grid[i][j+1].hasBuilding = true;
                  placed = true;
                }
              }
              if(!placed){
                let n = Math.floor(Math.random() * 3) + 1;
                if(n == 1){
                  let building = createbuilding1Model();
                  moveBuilding(building,1, tmp-i, tmp-j, rot);
                  city.push(building);
                  grid[i][j].hasBuilding = true;
                  placed = true;
                }
                else if(n==2){
                  let building = createbuilding2Model();
                  moveBuilding(building,2, tmp-i, tmp-j, rot);
                  city.push(building);
                  grid[i][j].hasBuilding = true;
                  placed = true;

                }
                else{
                  let building = createbuilding3Model();
                  moveBuilding(building,3, tmp-i, tmp-j, rot);
                  city.push(building);
                  grid[i][j].hasBuilding = true;
                  placed = true;
                }
              }
            }
          }
          /*
          else if (!grid[i][j].isSelected){
            let road = createRoad();
            if(j-1 < 0 || j + 1 >= gridSize ){
              moveBuilding(road,1, tmp-i, tmp-j, 1);
            }
            else{
              if(!grid[i][j-1].isSelected || !grid[i][j+1].isSelected){
                moveBuilding(road,1, tmp-i, tmp-j, 0);
              }
              else{
                moveBuilding(road,1, tmp-i, tmp-j, 1);
              }
            }
            city.push(road);
          }*/
        }
      }

    }
    function resetCity(){
      city =[];
      for(let i = 0; i < gridSize; i++){
        for(let j = 0; j < gridSize; j++){
          grid[i][j].hasBuilding = false;
        }
      }
    }

    function inBuilding(x,y){
      let tmp = Math.floor(gridSize/2);
      // x = x-tmp;
      // y = y-tmp;
      for(let i=0; i < gridSize; i++){
        for(let j =0; j<gridSize; j++){
          if(grid[i][j].hasBuilding){
            let xmin = tmp - i - 0.6;
            let xmax = tmp - i + 0.6;
            let ymin = tmp - j - 0.6;
            let ymax = tmp - j + 0.6;
            if((xmin < x && xmax > x) && (ymin < y && ymax > y)){
              // console.log("in building");
              return true;
            }
          }
        }
      }
      return false;
    }
    
    function getRandomInt(min, max){
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max-min+1)+min);
    }
    let cbox = addGeometry(makePrism(0.1,0.1,0.1,0,0,0), "textures/box.png", "textures/grid.png", makeMaterial(0.3, 0.7, 0.2, 5), 0);
    let package = createNode((gl) => drawfunc(gl, cbox), cbox);
    package.translation[1] = 0.05 - 2.5;
    let testCube = addGeometry(makePrism(0.05,5.0,0.05, 0,0,0), "textures/bluebeam.png", "textures/white.jpg", makeMaterial(0.8, 1, 0, 1), 0);
    tcube = createNode((gl) => drawfunc(gl, testCube), testCube);
    let testCube2 = addGeometry(makePrism(0.05,5.0,0.05, 0,0,0), "textures/redbeam.png", "textures/white.jpg", makeMaterial(0.8, 1, 0, 1), 0);
    destBeam = createNode((gl) => drawfunc(gl, testCube2), testCube2);
    tcube.translation[1] = 2.5;
    destBeam.translation[1] = 2.5;
    addChild(tcube, package);
    
    //======================================= Person =====================================================================
    const characterGeometries = initializeCharacterGeometries(addGeometry, makeMaterial);
    const characterRoot = createCharacterModel(characterGeometries, drawfunc);
    let base = addGeometry( makePlane(0.001,0.001,1,0,0), "textures/white.jpg", "textures/white.jpg", makeMaterial(0.3, 0.5, 0.95, 40), 8);
    let baseH = createNode((gl) => drawfunc(gl, base), base);
    baseH.scale = [0.4,0.4,0.4];
    baseH.localTransform = mat4Translate(mat4Identity(), [0, 1.15, 0]);

    let locationmatrix = mat4Identity(); 
    let tracker = addGeometry( makePlane(0.2,0.2,0.2,1,0,0), "textures/white.jpg", "textures/white.jpg", makeMaterial(0.3, 0.5, 0.95, 40), 8);

    addChild(baseH, characterRoot);
    characterRoot.rotation = [0,180*Math.PI/180, 0];
    let movx = 0, movy = 0, movz = 0;

    function invertRotationMatrix(mat) {
    // For a 4x4 matrix, transpose the 3x3 rotation part
      return [
        mat[0], mat[4], mat[8], 0,
        mat[1], mat[5], mat[9], 0,
        mat[2], mat[6], mat[10], 0,
        0, 0, 0, 1
      ];
    }


    let inverseRotation = mat4Identity();
    function render() {
      
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.clearColor(0.51, 0.78, 0.90, 1);
      // gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // rotation matrices
      let cx = Math.cos(cubeRotY), sx = Math.sin(cubeRotY);
      let cy = Math.cos(cubeRotX), sy = Math.sin(cubeRotX);
      let rotX = [1, 0, 0, 0, 0, cy, sy, 0, 0, -sy, cy, 0, 0, 0, 0, 1];
      let rotY = [cx, 0, -sx, 0, 0, 1, 0, 0, sx, 0, cx, 0, 0, 0, 0, 1];
      let cubeRotation = multiplyMat4(rotY, rotX);
      

      // init model-view matrix as identity matrix
      let modelViewMatrix = mat4Identity();
      // init model transformation matrix as identity matrix
      let modelTransformationMatrix = mat4Identity();

      //delta time in ms
      let deltaTime = Date.now() - startTime;
      // object rotation
      modelTransformationMatrix = multiplyMat4(modelTransformationMatrix, cubeRotation);
      modelTransformationMatrix = multiplyMat4(modelTransformationMatrix, inverseRotation); // Apply inverse rotation
      modelTransformationMatrix = mat4Translate(modelTransformationMatrix, [movx, movy, movz]);
      // camera translation
     
      modelViewMatrix = mat4Translate(modelViewMatrix, [camX, camY, camZ]);
      modelViewMatrix = multiplyMat4(modelViewMatrix, cubeRotation);
      
      
      //set time in seconds
      gl.uniform1f(timeLoc, deltaTime/1000.0);
      gl.uniformMatrix4fv(uPM, false, proj);
      gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);
      gl.uniformMatrix4fv(uMTM, false, modelTransformationMatrix);

      //set up lights
      gl.uniform3fv(uLightAPosLoc, [10,10,10]);
      gl.uniform3fv(uLightBPosLoc, [-10,10,-10]);
      gl.uniform3fv(uViewPosLoc, [0.0, 0.0, 0.0]);

      for(let j=0; j<gridSize; j++){
        for(let k=0; k<gridSize; k++){
          if(j==gridRow && k==gridCol && worldMode == "gridView"){
            if(selecting == "erasing"){
              if(grid[j][k].isSelected) grid[j][k].texture = selectedEraseTex;
              else grid[j][k].texture = eraseTex;
            }
            else{
              if(grid[j][k].isSelected) grid[j][k].texture = selectedHoveredTex;
              else grid[j][k].texture = hoveredTex;
            }
          }
          else if(grid[j][k].isSelected) grid[j][k].texture = selectedTex;
          else grid[j][k].texture = unselectedTex;
          grid[j][k].transformations = multiplyMat4(modelTransformationMatrix, mat4Translate(mat4Identity(), [Math.floor(gridSize/2) - j, -0.05, Math.floor(gridSize/2) - k]));
          drawStrayFunc(gl, grid[j][k]);
        }
      }
      for(let j=0; j < city.length; j++){
        drawNode(gl, city[j], modelTransformationMatrix);
      }


      //============= Draw Person ===================
      if(finishWalk || startWalk){
        finishWalk = walk(deltaTime);
      }

      if(forward){
        startWalk = true;
        characterRoot.translation[2] -= 0.0125;
        characterRoot.rotation[0] = 20 * Math.PI/180;
        locationmatrix =  multiplyMat4( multiplyMat4( translationMatrix(baseH.translation), rotationMatrix(baseH.rotation)), translationMatrix(characterRoot.translation));
        locationmatrix[13] = 0;
        baseH.translation = [locationmatrix[12], locationmatrix[13], locationmatrix[14]];
        movx = -locationmatrix[12];
        // movy = -locationmatrix[13];
        movz = -locationmatrix[14];
        inverseRotation = invertRotationMatrix(locationmatrix);
        characterRoot.translation = [0,0,0];
        if(inBuilding(locationmatrix[12], locationmatrix[14])){
          startWalk = true;
          characterRoot.translation[2] += 0.0125;
          characterRoot.rotation[0] = 20 * Math.PI/180;
          locationmatrix =  multiplyMat4( multiplyMat4( translationMatrix(baseH.translation), rotationMatrix(baseH.rotation)), translationMatrix(characterRoot.translation));
          locationmatrix[13] = 0;
          baseH.translation = [locationmatrix[12], locationmatrix[13], locationmatrix[14]];
          movx = -locationmatrix[12];
          movy = -locationmatrix[13];
          movz = -locationmatrix[14];
          inverseRotation = invertRotationMatrix(locationmatrix);
          characterRoot.translation = [0,0,0];
        }
      }
      if(backward){
        startWalk = true;
        characterRoot.rotation[0] = 20 * Math.PI/180;
        locationmatrix =  multiplyMat4( multiplyMat4( translationMatrix(baseH.translation), rotationMatrix(baseH.rotation)), translationMatrix(characterRoot.translation));
        locationmatrix[13] = 0;
        baseH.translation = [locationmatrix[12], locationmatrix[13], locationmatrix[14]];
        movx = -locationmatrix[12];
        movy = -locationmatrix[13];
        movz = -locationmatrix[14];
        inverseRotation = invertRotationMatrix(locationmatrix);
        characterRoot.translation = [0,0,0];
      }
      
      if(right){
        startWalk = true;
        characterRoot.rotation[0] = 20 * Math.PI/180;
        baseH.rotation[1] -= 2 * Math.PI/180;
        locationmatrix =  multiplyMat4( multiplyMat4( translationMatrix(baseH.translation), rotationMatrix(baseH.rotation)), translationMatrix(characterRoot.translation));
        locationmatrix[13] = 0;
        baseH.translation = [locationmatrix[12], locationmatrix[13], locationmatrix[14]];
        movx = -locationmatrix[12];
        movy = -locationmatrix[13];
        movz = -locationmatrix[14];
        inverseRotation = invertRotationMatrix(locationmatrix);
        characterRoot.translation = [0,0,0];
      }
      
      if(left){
        startWalk = true;
        characterRoot.rotation[0] = 20 * Math.PI/180;
        baseH.rotation[1] += 2 * Math.PI/180;
        locationmatrix =  multiplyMat4( multiplyMat4( translationMatrix(baseH.translation), rotationMatrix(baseH.rotation)), translationMatrix(characterRoot.translation));
        locationmatrix[13] = 0;
        baseH.translation = [locationmatrix[12], locationmatrix[13], locationmatrix[14]];
        inverseRotation = invertRotationMatrix(locationmatrix);
        characterRoot.translation = [0,0,0];
      }
      
      if(forward == false && backward == false && right == false && left == false){
        characterRoot.rotation[0] = [0];
        baseH.translation = [locationmatrix[12], locationmatrix[13], locationmatrix[14]];
        characterRoot.translation = [0,0,0];
      }
      
      tracker.transformations = multiplyMat4(modelTransformationMatrix, locationmatrix);

      characterRoot.translation[1] = 0.53;
      baseH.translation[1] = 0.025;
      drawNode(gl, baseH, modelTransformationMatrix);


      let numBuildings = buildingTiles.length;
      if(worldMode == "personView"){
        if(packageStatus == "none"){
          let randomi = getRandomInt(0, numBuildings-1);
          let r = buildingTiles[randomi].row;
          let c = buildingTiles[randomi].col;
          let tmp = Math.floor(gridSize/2);
          let randdir = getRandomInt(1,4);
          if(randdir == 1 && r+1 < gridSize){
            if(!grid[r + 1][c].hasBuilding){
              packagePosition = [tmp - (r+1), 2, tmp-c];
              packageGridCoords = [r+1, c];
              packageStatus = "waiting"
            }
          }
          else if(randdir == 2 && r-1 >= 0){
            if(!grid[r - 1][c].hasBuilding){
              packagePosition = [tmp - (r-1), 2, tmp-c];
              packageGridCoords = [r-1, c];
              packageStatus = "waiting"
            }
          }
          else if(randdir == 3 && c+1 < gridSize){
            if(!grid[r][c + 1].hasBuilding){
              packagePosition = [tmp - r, 2, tmp-(c+1)];
              packageGridCoords = [r, c+1];
              packageStatus = "waiting"
            }
          }
          else if(randdir == 4 && c-1 >= 0){
            if(!grid[r][c - 1].hasBuilding){
              packagePosition = [tmp - r, 2, tmp-(c-1)];
              packageGridCoords = [r, c-1];
              packageStatus = "waiting"
            }
          }
        }
        else if(packageStatus == "waiting" && packagePosition){
          grid[packageGridCoords[0]][packageGridCoords[1]].texture = selectedHoveredTex;
          movePackage(tcube, packagePosition[0], packagePosition[2]);
          drawNode(gl, tcube, modelTransformationMatrix);
          
          let packageMinX = packagePosition[0] - 0.5;
          let packageMaxX = packagePosition[0] + 0.5;
          let packageMinZ = packagePosition[2] - 0.5;
          let packageMaxZ = packagePosition[2] + 0.5;

          if(locationmatrix[12] > packageMinX && locationmatrix[12] < packageMaxX &&
            locationmatrix[14] > packageMinZ && locationmatrix[14] < packageMaxZ){
              grid[packageGridCoords[0]][packageGridCoords[1]].texture = unselectedTex;

              let randomi = getRandomInt(0, numBuildings-1);
              let r = buildingTiles[randomi].row;
              let c = buildingTiles[randomi].col;
              let tmp = Math.floor(gridSize/2);
              let randdir = getRandomInt(1,4);
              let deliveryPosFound = false;
              if(randdir == 1 && r+1 < gridSize){
                if(!grid[r + 1][c].hasBuilding){
                  deliveryPosition = [tmp - (r+1), 2, tmp-c];
                  deliveryGridCoords = [r+1, c];
                  deliveryPosFound = true;
                }
              }
              else if(randdir == 2 && r-1 >= 0){
                if(!grid[r - 1][c].hasBuilding){
                  deliveryPosition = [tmp - (r-1), 2, tmp-c];
                  deliveryGridCoords = [r-1, c];
                  deliveryPosFound = true;
                }
              }
              else if(randdir == 3 && c+1 < gridSize){
                if(!grid[r][c + 1].hasBuilding){
                  deliveryPosition = [tmp - r, 2, tmp-(c+1)];
                  deliveryGridCoords = [r, c+1];
                  deliveryPosFound = true;
                }
              }
              else if(randdir == 4 && c-1 >= 0){
                if(!grid[r][c - 1].hasBuilding){
                  deliveryPosition = [tmp - r, 2, tmp-(c-1)];
                  deliveryGridCoords = [r, c-1];
                  deliveryPosFound = true;
                }
              }
              if(deliveryPosFound) packageStatus = "picked";
          }
        }
        else if(packageStatus == "picked"){
          grid[deliveryGridCoords[0]][deliveryGridCoords[1]].texture = selectedEraseTex;
          movePackage(destBeam, deliveryPosition[0], deliveryPosition[2]);
          drawNode(gl, destBeam, modelTransformationMatrix);

          let deliveryMinX = deliveryPosition[0] - 0.5;
          let deliveryMaxX = deliveryPosition[0] + 0.5;
          let deliveryMinZ = deliveryPosition[2] - 0.5;
          let deliveryMaxZ = deliveryPosition[2] + 0.5;
          if(locationmatrix[12] > deliveryMinX && locationmatrix[12] < deliveryMaxX &&
            locationmatrix[14] > deliveryMinZ && locationmatrix[14] < deliveryMaxZ){
              grid[deliveryGridCoords[0]][deliveryGridCoords[1]].texture = unselectedTex;
              score ++;
              document.getElementById('score-display').textContent = score;
              console.log("score: ",score);
              packageStatus = "none";
          }
        }
      }

    }

    // Initialize when page loads
    window.onload = function () {
      setInterval(render, 30);
    }

  </script>
</body>

</html>